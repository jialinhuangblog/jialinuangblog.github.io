<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Frontend Server-Side Calls and CORS</title></head><body><article class="page serif"><header><h1 class="page-title">Frontend Server-Side Calls and CORS</h1><p class="page-description"></p><table class="properties"><tbody><tr class="property-row property-row-created_by"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesCreatedBy"><path d="M8 15.126C11.8623 15.126 15.0615 11.9336 15.0615 8.06445C15.0615 4.20215 11.8623 1.00293 7.99316 1.00293C4.13086 1.00293 0.938477 4.20215 0.938477 8.06445C0.938477 11.9336 4.1377 15.126 8 15.126ZM8 10.4229C6.05176 10.4229 4.54785 11.1133 3.83008 11.9131C2.90039 10.9082 2.33301 9.55469 2.33301 8.06445C2.33301 4.91992 4.84863 2.39746 7.99316 2.39746C11.1377 2.39746 13.6738 4.91992 13.6738 8.06445C13.6738 9.55469 13.1064 10.9082 12.1699 11.9131C11.4521 11.1133 9.94824 10.4229 8 10.4229ZM8 9.30176C9.32617 9.30859 10.3516 8.18066 10.3516 6.71094C10.3516 5.33008 9.31934 4.18164 8 4.18164C6.6875 4.18164 5.6416 5.33008 5.64844 6.71094C5.65527 8.18066 6.68066 9.28809 8 9.30176Z"></path></svg></span>Created by</th><td><span class="user"><img src="Frontend%20Server-Side%20Calls%20and%20CORS%20084f60a5e0ad4bee91366ce601ade50f/IMG_2295.jpg" class="icon user-icon"/>JiaLin Huang</span></td></tr><tr class="property-row property-row-last_edited_time"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesCreatedAt"><path d="M8 15.126C11.8623 15.126 15.0615 11.9336 15.0615 8.06445C15.0615 4.20215 11.8623 1.00293 7.99316 1.00293C4.13086 1.00293 0.938477 4.20215 0.938477 8.06445C0.938477 11.9336 4.1377 15.126 8 15.126ZM8 13.7383C4.85547 13.7383 2.33301 11.209 2.33301 8.06445C2.33301 4.91992 4.84863 2.39746 7.99316 2.39746C11.1377 2.39746 13.6738 4.91992 13.6738 8.06445C13.6738 11.209 11.1445 13.7383 8 13.7383ZM4.54102 8.91211H7.99316C8.30078 8.91211 8.54004 8.67285 8.54004 8.37207V3.8877C8.54004 3.58691 8.30078 3.34766 7.99316 3.34766C7.69238 3.34766 7.45312 3.58691 7.45312 3.8877V7.83203H4.54102C4.2334 7.83203 4.00098 8.06445 4.00098 8.37207C4.00098 8.67285 4.2334 8.91211 4.54102 8.91211Z"></path></svg></span>Last edited</th><td><time>@2024å¹´9æœˆ29æ—¥ 20:41</time></td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesMultipleSelect"><path d="M1.91602 4.83789C2.44238 4.83789 2.87305 4.40723 2.87305 3.87402C2.87305 3.34766 2.44238 2.91699 1.91602 2.91699C1.38281 2.91699 0.952148 3.34766 0.952148 3.87402C0.952148 4.40723 1.38281 4.83789 1.91602 4.83789ZM5.1084 4.52344H14.3984C14.7607 4.52344 15.0479 4.23633 15.0479 3.87402C15.0479 3.51172 14.7607 3.22461 14.3984 3.22461H5.1084C4.74609 3.22461 4.45898 3.51172 4.45898 3.87402C4.45898 4.23633 4.74609 4.52344 5.1084 4.52344ZM1.91602 9.03516C2.44238 9.03516 2.87305 8.60449 2.87305 8.07129C2.87305 7.54492 2.44238 7.11426 1.91602 7.11426C1.38281 7.11426 0.952148 7.54492 0.952148 8.07129C0.952148 8.60449 1.38281 9.03516 1.91602 9.03516ZM5.1084 8.7207H14.3984C14.7607 8.7207 15.0479 8.43359 15.0479 8.07129C15.0479 7.70898 14.7607 7.42188 14.3984 7.42188H5.1084C4.74609 7.42188 4.45898 7.70898 4.45898 8.07129C4.45898 8.43359 4.74609 8.7207 5.1084 8.7207ZM1.91602 13.2324C2.44238 13.2324 2.87305 12.8018 2.87305 12.2686C2.87305 11.7422 2.44238 11.3115 1.91602 11.3115C1.38281 11.3115 0.952148 11.7422 0.952148 12.2686C0.952148 12.8018 1.38281 13.2324 1.91602 13.2324ZM5.1084 12.918H14.3984C14.7607 12.918 15.0479 12.6309 15.0479 12.2686C15.0479 11.9062 14.7607 11.6191 14.3984 11.6191H5.1084C4.74609 11.6191 4.45898 11.9062 4.45898 12.2686C4.45898 12.6309 4.74609 12.918 5.1084 12.918Z"></path></svg></span>Tags</th><td><span class="selected-value select-value-color-default">HTTP</span><span class="selected-value select-value-color-red">Nextjs</span><span class="selected-value select-value-color-blue">Reactjs</span></td></tr></tbody></table></header><div class="page-body"><p class="">
</p><h1 class="">WHY</h1><p class="">When dealing with <strong>sensitive information</strong> such as login or account-related matters, including sessions and tokens, one might wonder <strong>how to hide this information instead of having it visible in the browser&#x27;s console</strong>. A common approach is to avoid using Client API and instead <span style="border-bottom:0.05em solid">utilize the NextJS Server functionality provided by the NextJS framework</span>. For example, you can define dedicated server-side code in the <code>actions/</code> directory to handle these sensitive operations.</p><p class="">
</p><p class="">To put it simply, instead of calling client APIs (e.g. useSWR) in client components, you call server-side code, asking your <span style="border-bottom:0.05em solid">frontend&#x27;s backend NextJS Server</span> to make requests to the backend on your behalf.</p><p class="">The advantage of this approach is that the requests won&#x27;t show up when debugging using dev tools. To debug these operations, we need to check the server&#x27;s log output, which could be in the shell terminal or elsewhere.</p><p class=""><mark class="highlight-red"><strong>I discovered that &quot;CORS issues occur when sending requests from client API browsers, but there&#x27;s no problem when the NextJS Server makes the requests</strong></mark></p><p class="">
</p><p class="">
</p><h1 class="">The Broad Concept of Client</h1><p class="">When discussing CORS and API calls, it&#x27;s important to ensure a consistent understanding of what &quot;client&quot; means. It doesn&#x27;t just refer to browsers, but to any request initiator relative to the backend API server. This can include:</p><ul class="bulleted-list"><li style="list-style-type:disc">Traditional web browsers</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">API testing tools (like Postman)</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">CLI (like curl)</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Server-side code (like functions in the <code>actions/</code> directory of NextJS)</li></ul><p class="">
</p><h1 class="">CORS</h1><p class="">CORS is a <mark class="highlight-red"><strong>self-protection mechanism of the browser</strong></mark>. Its purpose is to prevent users from unknowingly sending requests to unknown sources or exposing sensitive information to unauthorized recipients. Therefore, <strong>CORS only constrains browser environments</strong> and does not affect NextJS Server applications or common API testing tools (e.g., Postman, Insomnia).</p><p class="">
</p><p class="">This explains why we often see <mark class="highlight-red">&quot;Backend says it&#x27;s good to go, but frontend&#x27;s still stuck. They swear it works in Postman!&quot;</mark></p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">CORS-related Headers</h1><h3 class="">clientâ€™s  (a.k.a browser)</h3><p class="">shortcut: <code>ACR-[name]</code> for <code>Access-Control-Request</code></p><ol type="1" class="numbered-list" start="1"><li><code>Origin</code>: Where it comes (protocol + domain + port)<p class="">preflight/OPTIONS both need to have this header</p></li></ol><ol type="1" class="numbered-list" start="2"><li><code>ACR-Method</code></li></ol><ol type="1" class="numbered-list" start="3"><li><code>ACR-Headers</code></li></ol><p class="">
</p><h3 class="">Serverâ€™s</h3><p class=""><code>Access-Control-Allow</code> as <code><strong>ACA</strong></code></p><ol type="1" class="numbered-list" start="1"><li><code>ACA-Origin</code>:  Manages the domain whitelist that can access the server<ul class="bulleted-list"><li style="list-style-type:disc">If your current website&#x27;s request is not accepted by the server, meaning your browser origin is not in the server&#x27;s whitelist, the browser check will tell you <br/><br/><strong>&quot;Hey, you can&#x27;t see this&quot;</strong></li></ul></li></ol><ol type="1" class="numbered-list" start="2"><li><code>ACA-Methods</code>: HTTP methods (like GET, POST, PUT, DELETE, etc.)<ul class="bulleted-list"><li style="list-style-type:disc">No need to include Options</li></ul></li></ol><ol type="1" class="numbered-list" start="3"><li><code>ACA-Headers</code>: Specifies allowed headers<p class="">e.g. <code>ACA-Headers: Content-Type, Authorization, X-Requested-With</code></p></li></ol><ol type="1" class="numbered-list" start="4"><li><code>ACA-Credentials</code>: Whether cookies can be sent.<ul class="bulleted-list"><li style="list-style-type:disc">There&#x27;s only one situation where it&#x27;s <mark class="highlight-red">true</mark>, otherwise it doesn&#x27;t need to be set<p class=""><a href="https://stackoverflow.com/questions/19743396/cors-cannot-use-wildcard-in-access-control-allow-origin-when-credentials-flag-i">https://stackoverflow.com/questions/19743396/cors-cannot-use-wildcard-in-access-control-allow-origin-when-credentials-flag-i</a></p><ul class="bulleted-list"><li style="list-style-type:circle">Frontend paired with: <code>withCredentials: true</code></li></ul><ul class="bulleted-list"><li style="list-style-type:circle">And the backend <code>ACA-Origin</code> can&#x27;t directly use wildcard *</li></ul></li></ul></li></ol><ol type="1" class="numbered-list" start="5"><li><code>Access-Control-Max-Age</code>: Tells how long the browser can remember the &quot;Can I?&quot; answer.<ul class="bulleted-list"><li style="list-style-type:disc">For a specific endpoint, not for all endpoints under the entire server</li></ul></li></ol><p class="">
</p><p class="">
</p><h1 class="">Preflight/OPTIONS Request Response Steps</h1><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex"><div style="font-size:1.5em"><span class="icon">ðŸ’¡</span></div><div style="width:100%"><p class="">&quot;Preflight&quot; is a term describing the purpose of this request, while OPTIONS is the HTTP method implementing this purpose<br/>preflight is the concept, options is the practice<br/></p></div></figure><ol type="1" class="numbered-list" start="1"><li>When the browser sees a fancy request (not just GET/POST/HEAD), it first sends a &quot;May I?&quot; request (OPTIONS) to check if the server&#x27;s cool with it.<ol type="a" class="numbered-list" start="1"><li><strong>Simple requests</strong>: No needed preflight, they can be sent directly. If failed, you&#x27;ll receive a response with a 200 status but with a <mark class="highlight-red">CORS error</mark>, and the browser will refuse to read the result with Javascript. <strong>(I remember Firefox and Chrome react slightly differently to this situation, but both indeed have CORS errors)</strong><blockquote class="">The characteristic of<mark class="highlight-red"> simple requests is that they don&#x27;t cause effects on the server</mark>, so they are allowed to be sent directly</blockquote></li></ol><ol type="a" class="numbered-list" start="2"><li><strong>Non-simple requests</strong>: Require preflight. If the preflight fails, the actual PUT/DELETE request won&#x27;t be sent</li></ol></li></ol><ol type="1" class="numbered-list" start="2"><li>This request includes <ol type="a" class="numbered-list" start="1"><li><code>Access-Control-Request-Method</code></li></ol><ol type="a" class="numbered-list" start="2"><li><code>Access-Control-Request-Headers</code></li></ol></li></ol><ol type="1" class="numbered-list" start="3"><li>The server responds to the OPTIONS request, including the corresponding CORS headers.<ul class="bulleted-list"><li style="list-style-type:disc">If the server agrees, the browser will then send the <mark class="highlight-red">actual request</mark></li></ul><ul class="bulleted-list"><li style="list-style-type:disc"><code>Access-Control-Allow-Origin</code>: Must include the <code>Origin</code> of the request, or be *</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Other related <code>Access-Control-*</code> headers, set according to actual needs</li></ul></li></ol><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">Bad Website and Bank without CORS</h1><p class="block-color-red_background">Scenario: </p><ol type="1" class="block-color-red_background numbered-list" start="1"><li>You are logged in to Bank Y with not set up CORS. </li></ol><ol type="1" class="block-color-red_background numbered-list" start="2"><li>At the same time, you accidentally browse the malicious website <span style="border-bottom:0.05em solid">evil.com</span>. </li></ol><ol type="1" class="block-color-red_background numbered-list" start="3"><li>The malicious website obtains the secret cookies between you and Bank Y, and then sends a transfer request, which is a CSRF attack.</li></ol><p class="">Although CORS cannot prevent CSRF attacks, it can prevent attackers from reading the response.</p><h3 class="">CSRF Attack</h3><ul class="bulleted-list"><li style="list-style-type:disc">When you visit evil.com, it tries to send a request to bank.com, and the browser will automatically attach cookies belonging to bank.com to this request.<ul class="bulleted-list"><li style="list-style-type:circle">evil.com can&#x27;t read but can use cookies.</li></ul></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">CORS can&#x27;t prevent bad scripts from &quot;stealing&quot; your cookies.<blockquote class="">The security of Cookies mainly relies on the <code>HttpOnly</code> and <code>Secure</code> flags. <strong>evil.com can only try to borrow, but can&#x27;t see.<br/><br/></strong><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#httponly">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#httponly</a></blockquote></li></ul><h3 class="">CORS</h3><ul class="bulleted-list"><li style="list-style-type:disc">Has a whitelist of request origins</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">It doesn&#x27;t prevent requests, but can prevent responses from being read.</li></ul><p class="">Other methods to prevent CSRF:</p><ul class="bulleted-list"><li style="list-style-type:disc">Use CSRF tokens</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Check the Referer header</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Use the <code>SameSite</code> cookie attribute</li></ul><p class="">
</p><h1 class="">Bad Script vs. Bank without CORS</h1><p class="block-color-red_background">Scenario: </p><ol type="1" class="block-color-red_background numbered-list" start="1"><li>I&#x27;m browsing a very well-behaved website trusted-site.com. </li></ol><ol type="1" class="block-color-red_background numbered-list" start="2"><li>trusted-site.com believes that ad-scripts.com itself works normally without anything bad, but it actually has bad intent.</li></ol><ol type="1" class="block-color-red_background numbered-list" start="3"><li>So it tries to send a transfer request bank.com/transfer. Of course, as in the previous scenario, the browser knows you&#x27;re going to the bank website, so it brings the cookies along.</li></ol><h3 class="">Without CORS</h3><p class="">The bank side sees the cookies and thinks it&#x27;s ok, so it responds to you. <mark class="highlight-red">Therefore, ad-scripts.com can freely access the response you received.</mark></p><h3 class="">With CORS:</h3><p class="">The browser will check the headers and find that trusted-site.com is not on the whitelist.</p><ul class="bulleted-list"><li style="list-style-type:disc">Simple requests: No preflight is needed to send the actual request, but the browser won&#x27;t let you read the response</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Non-simple requests:<ul class="bulleted-list"><li style="list-style-type:circle">If OPTIONS comes back as a failure, it ends</li></ul><ul class="bulleted-list"><li style="list-style-type:circle">If OPTIONS comes back successful, it continues with the actual request, but subsequently, the browser check may also not allow reading the response</li></ul></li></ul><h3 class="">Conclusion</h3><ol type="1" class="numbered-list" start="1"><li>ad-scripts.com (bad guy)</li></ol><ol type="1" class="numbered-list" start="2"><li>trusted-site.com (kind but idiot)</li></ol><ol type="1" class="numbered-list" start="3"><li>bank.com/transfer</li></ol><p class="">
</p><h1 class="">CORS Alone Is Not Enough!</h1><p class="">In the above scenario, if trusted-site.com itself is not secure enough, and the bank server still puts trusted-site.com on the whitelist, then CORS is useless. CORS only recognizes where the incoming request is from, but doesn&#x27;t know that there are many bad scripts within the request source.</p><p class="">CORS only recognizes place, not the bad buildings built on that place</p><p class=""><strong>Solutionsï¼š</strong></p><ol type="a" class="numbered-list" start="1"><li>Strictly limit the CORS origin list aka whitelist</li></ol><ol type="a" class="numbered-list" start="2"><li>OAuth or API</li></ol><ol type="a" class="numbered-list" start="3"><li>Content Security Policy (CSP) header setup<ol type="a" class="numbered-list" start="1"><li>CSP was designed to protect against <mark class="highlight-red"><strong>XSS</strong></mark> attacks</li></ol></li></ol><ol type="a" class="numbered-list" start="4"><li>Subresource Integrity (SRI)<ol type="a" class="numbered-list" start="1"><li>Prevents CDN tampering</li></ol><p class=""><a href="https://imququ.com/post/subresource-integrity.html">https://imququ.com/post/subresource-integrity.html</a></p></li></ol><ol type="a" class="numbered-list" start="5"><li>Principle of least privilege</li></ol><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">Some Thoughts</h1><h3 class="">Thought 1</h3><p class="">While browsers have CORS, other clients like mobile apps or server-to-server communications need different security solution...</p><p class="">There is a secret between client and server.</p><ol type="1" class="numbered-list" start="1"><li>Client: <br/>uses a secret key (usually only known to the client and server). Combine key parts of the request (such as URL, timestamp, request body etc.) and then use an encryption (such as HMAC-SHA256) to generate a signature.<br/></li></ol><ol type="1" class="numbered-list" start="2"><li>Server: <br/>The server recalculates the signature using the same secret key and algorithm. check if <br/><span style="border-bottom:0.05em solid">calculated signature</span> = <span style="border-bottom:0.05em solid">signature in the request</span></li></ol><ol type="1" class="numbered-list" start="3"><li><strong>Security:</strong><ul class="bulleted-list"><li style="list-style-type:disc">Even if the request is intercepted, a valid signature cannot be forged without the secret key.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Can prevent the request from being changed, as any difference will result in a total signature result.</li></ul></li></ol><p class="">Use cases:</p><ul class="bulleted-list"><li style="list-style-type:disc">API request verification</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Payment systems</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">File upload verification</li></ul><p class="">Request signing provides stronger security than simple tokens, especially in preventing request tampering.</p><p class="">
</p><h3 class="">Thought 2</h3><p class=""><strong>What if:</strong> it&#x27;s just a simple request and therefore doesn&#x27;t send OPTIONS, but is rejected by the backend CORS?</p><p class=""><strong>Truth is:</strong> It doesn&#x27;t matter, you just receive a CORS error. The server doesn&#x27;t recognize you so it doesn&#x27;t return the relevant CORS headers, and then the browser gets the response and finds that your website is not on the server&#x27;s whitelist, <strong>so it just doesn&#x27;t let you access the response with Javascript (e.g., through </strong><code><strong>xhr.responseText</strong></code><strong> or </strong><code><strong>fetch</strong></code><strong>&#x27;s </strong><code><strong>response</strong></code><strong> object)</strong></p><p class="">If the server doesn&#x27;t include appropriate CORS headers in the response:<div class="indented"><ul class="bulleted-list"><li style="list-style-type:disc">You&#x27;ll see a CORS error in the console, but the network request itself is successful (you might see a 200 OK status in the network panel). <br/><br/><mark class="highlight-red"><strong>(CORS doesn&#x27;t block simple requests)</strong></mark></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">However, when JavaScript tries to read it, the browser will throw an error. <br/><br/><mark class="highlight-red"><strong>( but CORS blocks reading)</strong></mark></li></ul></div></p><p class="">
</p><h3 class="">Thought 3</h3><p class=""><strong>If</strong> a bad server opens CORS, the browser can pass CORS. Doesn&#x27;t this fail to achieve a self-protection mechanism?</p><p class="">No, in that case, we should question the security of the website you&#x27;re currently browsing, not the fact that the bas server opened CORS to allow anyone to send requests.</p><p class="">
</p><h3 class="">Thought 4</h3><p class="">In what scenarios would <code>Access-Control-Allow-Credentials: true</code> be used?</p><ul class="bulleted-list"><li style="list-style-type:disc">Bearer Token (no need <code>Access-Control-Allow-Credentials: true</code>)<ul class="bulleted-list"><li style="list-style-type:circle">Reduces CSRF (Cross-Site Request Forgery) attacks<p class="">Bearer token is not automatically sent by the browser like cookies are. The app has to manually include the token in each request, making it harder for bad sites to trick your browser into sending authenticated requests</p></li></ul></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Cookies / Sessions (needs <code>Access-Control-Allow-Credentials: true</code>)<ul class="bulleted-list"><li style="list-style-type:circle">traditional server-side rendered applications</li></ul><ul class="bulleted-list"><li style="list-style-type:circle">cross-domain situations that need special treatment</li></ul></li></ul><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class=""><a href="https://sentry.io/answers/why-does-my-javascript-code-receive-a-no-access-control-allow-origin-header-error-while-postman-does-not/">https://sentry.io/answers/why-does-my-javascript-code-receive-a-no-access-control-allow-origin-header-error-while-postman-does-not/</a></p><p class=""><a href="https://stackoverflow.com/questions/19743396/cors-cannot-use-wildcard-in-access-control-allow-origin-when-credentials-flag-i">https://stackoverflow.com/questions/19743396/cors-cannot-use-wildcard-in-access-control-allow-origin-when-credentials-flag-i</a></p><p class="">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body>