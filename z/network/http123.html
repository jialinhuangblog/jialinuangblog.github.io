<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>HTTP 1.1/2/3</title></head><body><article class="page serif"><header><div class="page-header-icon undefined"><img class="icon" src="https://www.notion.so/icons/fire_red.svg"/></div><h1 class="page-title">HTTP 1.1/2/3</h1><p class="page-description"></p><table class="properties"><tbody><tr class="property-row property-row-created_by"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesCreatedBy"><path d="M8 15.126C11.8623 15.126 15.0615 11.9336 15.0615 8.06445C15.0615 4.20215 11.8623 1.00293 7.99316 1.00293C4.13086 1.00293 0.938477 4.20215 0.938477 8.06445C0.938477 11.9336 4.1377 15.126 8 15.126ZM8 10.4229C6.05176 10.4229 4.54785 11.1133 3.83008 11.9131C2.90039 10.9082 2.33301 9.55469 2.33301 8.06445C2.33301 4.91992 4.84863 2.39746 7.99316 2.39746C11.1377 2.39746 13.6738 4.91992 13.6738 8.06445C13.6738 9.55469 13.1064 10.9082 12.1699 11.9131C11.4521 11.1133 9.94824 10.4229 8 10.4229ZM8 9.30176C9.32617 9.30859 10.3516 8.18066 10.3516 6.71094C10.3516 5.33008 9.31934 4.18164 8 4.18164C6.6875 4.18164 5.6416 5.33008 5.64844 6.71094C5.65527 8.18066 6.68066 9.28809 8 9.30176Z"></path></svg></span>Created by</th><td><span class="user"><img src="HTTP%201%201%202%203%201066cd51990d803d8e9cdf9096ca7e8c/IMG_2295.jpg" class="icon user-icon"/>JiaLin Huang</span></td></tr><tr class="property-row property-row-last_edited_time"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesCreatedAt"><path d="M8 15.126C11.8623 15.126 15.0615 11.9336 15.0615 8.06445C15.0615 4.20215 11.8623 1.00293 7.99316 1.00293C4.13086 1.00293 0.938477 4.20215 0.938477 8.06445C0.938477 11.9336 4.1377 15.126 8 15.126ZM8 13.7383C4.85547 13.7383 2.33301 11.209 2.33301 8.06445C2.33301 4.91992 4.84863 2.39746 7.99316 2.39746C11.1377 2.39746 13.6738 4.91992 13.6738 8.06445C13.6738 11.209 11.1445 13.7383 8 13.7383ZM4.54102 8.91211H7.99316C8.30078 8.91211 8.54004 8.67285 8.54004 8.37207V3.8877C8.54004 3.58691 8.30078 3.34766 7.99316 3.34766C7.69238 3.34766 7.45312 3.58691 7.45312 3.8877V7.83203H4.54102C4.2334 7.83203 4.00098 8.06445 4.00098 8.37207C4.00098 8.67285 4.2334 8.91211 4.54102 8.91211Z"></path></svg></span>Last edited</th><td><time>@2024Âπ¥9Êúà19Êó• 20:23</time></td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesMultipleSelect"><path d="M1.91602 4.83789C2.44238 4.83789 2.87305 4.40723 2.87305 3.87402C2.87305 3.34766 2.44238 2.91699 1.91602 2.91699C1.38281 2.91699 0.952148 3.34766 0.952148 3.87402C0.952148 4.40723 1.38281 4.83789 1.91602 4.83789ZM5.1084 4.52344H14.3984C14.7607 4.52344 15.0479 4.23633 15.0479 3.87402C15.0479 3.51172 14.7607 3.22461 14.3984 3.22461H5.1084C4.74609 3.22461 4.45898 3.51172 4.45898 3.87402C4.45898 4.23633 4.74609 4.52344 5.1084 4.52344ZM1.91602 9.03516C2.44238 9.03516 2.87305 8.60449 2.87305 8.07129C2.87305 7.54492 2.44238 7.11426 1.91602 7.11426C1.38281 7.11426 0.952148 7.54492 0.952148 8.07129C0.952148 8.60449 1.38281 9.03516 1.91602 9.03516ZM5.1084 8.7207H14.3984C14.7607 8.7207 15.0479 8.43359 15.0479 8.07129C15.0479 7.70898 14.7607 7.42188 14.3984 7.42188H5.1084C4.74609 7.42188 4.45898 7.70898 4.45898 8.07129C4.45898 8.43359 4.74609 8.7207 5.1084 8.7207ZM1.91602 13.2324C2.44238 13.2324 2.87305 12.8018 2.87305 12.2686C2.87305 11.7422 2.44238 11.3115 1.91602 11.3115C1.38281 11.3115 0.952148 11.7422 0.952148 12.2686C0.952148 12.8018 1.38281 13.2324 1.91602 13.2324ZM5.1084 12.918H14.3984C14.7607 12.918 15.0479 12.6309 15.0479 12.2686C15.0479 11.9062 14.7607 11.6191 14.3984 11.6191H5.1084C4.74609 11.6191 4.45898 11.9062 4.45898 12.2686C4.45898 12.6309 4.74609 12.918 5.1084 12.918Z"></path></svg></span>Tags</th><td><span class="selected-value select-value-color-purple">Post</span></td></tr></tbody></table></header><div class="page-body"><h1 class="">In this page</h1><ul class="bulleted-list"><li style="list-style-type:disc">HTTP/1.0 to HTTP/1.1</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">HTTP/1.1 to HTTP/2</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">HTTP/2 to HTTP/3, and understanding how to reach 0 RTT</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">HTTP Negotiation vs. HTTP Upgrade Header</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">‚Ä¶</li></ul><p class="">
</p><h1 class="">Terminologies</h1><h3 class=""><strong>RTT Concept</strong></h3><p class="">1 RTT represents a round trip. Below are all 1 RTT.</p><ol type="1" class="numbered-list" start="1"><li><mark class="highlight-red"><strong>TCP three-way handshake</strong></mark>: you might think it would be 1.5 RTT, but the third step only involves sending a packet without expecting a return, so it&#x27;s omitted.</li></ol><ol type="1" class="numbered-list" start="2"><li>Another example is when I use HTTP 1.1 to make a request with a header to upgrade to HTTP/2: 1 RTT.<ol type="a" class="numbered-list" start="1"><li>The client: Send an HTTP 1.1 request to the server.</li></ol><ol type="a" class="numbered-list" start="2"><li>The server responds with an HTTP/2 formatted response with a <code>101 Switching Protocols</code> status.</li></ol></li></ol><h3 class="">TCP Handshake</h3><p class="">TCP operates at the Transport layer, which is below the Network layer, also known as IP.</p><p class=""><mark class="highlight-red">Regardless of the HTTP version</mark>, TCP always requires a 3-way handshake to establish a connection.</p><ol type="1" class="numbered-list" start="1"><li>C ‚Üí S: SYN (Synchronize) Packet (Step 1)</li></ol><ol type="1" class="numbered-list" start="2"><li>S ‚Üí C: SYN-ACK (Synchronize-Acknowledge) Packet (Step 2)</li></ol><ol type="1" class="numbered-list" start="3"><li>C ‚ÜíS: ACK (Acknowledge) Packet (Step 3)</li></ol><h3 class="">OSI Wrapping: Alice &amp; Bob</h3><p class="">alice: segment() ‚Üí packet(segment()) ‚Üí frame(packet(segment()))</p><p class="">bob: frame(packet(segment())) ‚Üí packet(segment()) ‚Üí segment()</p><p class=""><strong>If Alice sends to Bob:</strong></p><ul class="bulleted-list"><li style="list-style-type:disc">Alice‚Äôs Application Data: The application generates data.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Alice‚Äôs HTTP Message: Headers and message body.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Alice‚Äôs HTTP/2 Frames: The data is fragmented (note: this frame is different from the OSI Frame). The latter is the Frame at the physical layer, which is the final wrapping stage.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Alice&#x27;s TCP Segments: Further divided into Segments, with sequence numbers, acknowledgments, and control information added.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Alice&#x27;s IP Packets: Segments are wrapped into Packets, adding IP addresses, routing information, and some metadata.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc"><strong>Alice&#x27;s Physical Frames: Finally, Packets are wrapped into Frames.</strong><p class=""><mark class="highlight-red"><strong>(Wrap: Frame ‚Üí Segment ‚Üí Packet ‚Üí Frame, getting bigger)</strong></mark></p></li></ul><p class=""><strong>Bob Unpacks:</strong></p><ul class="bulleted-list"><li style="list-style-type:disc"><strong>Bob‚Äôs Physical Frames</strong><p class=""><mark class="highlight-red"><strong>(Unwrap: Frame ‚Üí Packet ‚Üí Segment ‚Üí Frame, getting smaller)</strong></mark></p></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Bob‚Äôs IP Packets: The Frame is unwrapped, revealing the IP address, routing information, and metadata.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Bob‚Äôs TCP Segments: Extract sequence numbers, acknowledgments, and control information.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Bob‚Äôs HTTP/2 Frames: Segments are reassembled into Frames.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Bob&#x27;s HTTP Message: HTTP/2 frames are reconstructed into the original information, including headers and the message body.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Bob&#x27;s Application Data: Delivered to the application for further processing.</li></ul><p class="">
</p><p class="">
</p><h1 class="">HTTP</h1><ul class="bulleted-list"><li style="list-style-type:disc">Client/Server Model</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Is Stateless: Each transaction is independent and unrelated to other transactions, but cookies and sessions can give the impression of statefulness.</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Application Layer: 99.9% of the time, HTTP uses TCP as its transport layer protocol.<ul class="bulleted-list"><li style="list-style-type:circle">Exception: HTTP/3 is based on QUIC, which is built on UDP.</li></ul></li></ul><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">HTTPS Handshake</h1><ol type="1" class="numbered-list" start="1"><li>TCP Three-Way Handshake (the so-called TCP handshake)</li></ol><ol type="1" class="numbered-list" start="2"><li><strong>SSL/TLS Handshake (HTTP</strong><mark class="highlight-red"><strong>S</strong></mark><strong>), HTTP/2 NEED TLS.</strong><p class="">When the server does not support HTTP/2, it will ignore the client&#x27;s HTTP/2 support request and respond using HTTP/1.1 to indicate the protocol. (Just in case)</p><figure class="image"><a href="https://www.ssl2buy.com/wp-content/uploads/2018/08/ssl2buy-tls12-13.jpg"><img style="width:480px" src="https://www.ssl2buy.com/wp-content/uploads/2018/08/ssl2buy-tls12-13.jpg"/></a></figure><ol type="a" class="numbered-list" start="1"><li><strong>TLS 1.2</strong> consumes 2 RTTs<ol type="a" class="numbered-list" start="1"><li>Client sends <code>ClientHello</code>, server responds with <code>ServerHello</code>, <code>Certificate</code>, <code>ServerKeyExchange</code>, <code>ServerHelloDone</code>.</li></ol><ol type="a" class="numbered-list" start="2"><li>Client sends <code>ClientKeyExchange</code>, <code>ChangeCipherSpec</code>, <code>Finished</code>, server responds with <code>ChangeCipherSpec</code>, <code>Finished</code>.</li></ol></li></ol><ol type="a" class="numbered-list" start="2"><li><strong>TLS 1.3</strong> consumes 1 RTT<ol type="a" class="numbered-list" start="1"><li>Client sends <code>ClientHello</code> (including the shared key), server responds with <code>ServerHello</code>, ..., <code>Finished</code>.</li></ol></li></ol></li></ol><ol type="1" class="numbered-list" start="3"><li>Start Conversation üòÑüòÑüòÑ</li></ol><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">HTTP 1.1: What‚Äôs the better than 1.0?</h1><ol type="1" class="numbered-list" start="1"><li><strong>Persisted TCP Connection</strong>: HTTP 1.1 introduced the <strong>Keep Alive</strong> header, allowing a single connection to be established with the server, meaning that requests and responses can be exchanged <mark class="highlight-red">without repeatedly performing the TCP handshake as in HTTP 1.0</mark>.<p class="">While HTTP is generally <mark class="highlight-red"><strong>stateless</strong></mark>, HTTP 1.1 may seem stateful due to the persistent connection. However, by the strict definitions of stateful/stateless, <mark class="highlight-red"><strong>the focus is mainly on sessions and cookies.</strong></mark> This also applies to HTTP/2.</p><blockquote class="">All protocols are always stateful because TCP is stateful.<p class="">While the &quot;keep-alive&quot; mechanism doesn&#x27;t store application-specific state between requests (as it&#x27;s still fundamentally a stateless protocol), it does introduce some persistence at the connection level, improving the efficiency of handling multiple requests within a single connection. This is in contrast to the default behavior of HTTP/1.0, where each request typically involved a separate connection.</p></blockquote></li></ol><ol type="1" class="numbered-list" start="2"><li><strong>Streaming Chunked</strong>: For example, when an image loads in pieces.</li></ol><ol type="1" class="numbered-list" start="3"><li><strong>Pipelining</strong>: In HTTP 1.0, each request must wait for the previous request to finish. In 1.1, multiple requests can be sent out, but they must return in order. This only partially resolves the head-of-line blocking (HOLB) issue from 1.0.<br/><br/><mark class="highlight-red"><strong>(Note: This feature in 1.1 is disabled by default and wasn&#x27;t widely adopted).</strong></mark></li></ol><ol type="1" class="numbered-list" start="4"><li><strong>Caching:</strong><ol type="a" class="numbered-list" start="1"><li>1.0 - <code>If-Modified-Since</code> and <code>Expires</code></li></ol><ol type="a" class="numbered-list" start="2"><li>1.1 - <code>Cache-Control</code>, <code>ETag</code>, and <code>Vary</code></li></ol></li></ol><ol type="1" class="numbered-list" start="5"><li><strong>Host Header:</strong> Not required in 1.0.</li></ol><ol type="1" class="numbered-list" start="6"><li><strong>Virtual Hosting:</strong> Due to the lack of a Host header in 1.0, virtual hosting wasn‚Äôt possible.</li></ol><ol type="1" class="numbered-list" start="7"><li><strong>Content Negotiation:</strong> 1.1 supports <code>Accept</code> and <code>Content-Type</code> headers.</li></ol><ol type="1" class="numbered-list" start="8"><li><strong>Range Requests</strong>: HTTP 1.1 introduced standardized support for range requests.<ol type="a" class="numbered-list" start="1"><li>request<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Plain Text">GET /resource HTTP/1.1
Range: bytes=0-499</code></pre></li></ol><ol type="a" class="numbered-list" start="2"><li>response<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Plain Text">HTTP/1.1 206 Partial Content
Content-Range: bytes 0-499/1234</code></pre></li></ol></li></ol><p class="">
</p><p class="">
</p><h3 class="">Does HTTP/1.1 have connection limits?</h3><p class=""><a href="https://queue.acm.org/detail.cfm?">https://queue.acm.org/detail.cfm?id=2555617</a></p><blockquote class="">Modern browsers allow up to six parallel connections per origin</blockquote><p class="">Modern browsers allow up to six parallel connections per origin.</p><p class="">
</p><h3 class="">Browsers Always Use HTTP, Right?</h3><p class="">Yes, but HTTP is not limited to use in browsers.</p><p class="">For example, gRPC is a remote procedure call system built on HTTP/2, but it cannot be directly called in a browser. Instead, libraries like gRPC-Web help convert gRPC to a web-friendly format.<div class="indented"><p class=""><strong>What is gRPC?</strong><br/>Remote Procedure Call, with &quot;g&quot; standing for Google. It offers better performance and more efficient data transmission. Of course, it&#x27;s closer to the underlying system, making it harder to read. However, because it&#x27;s harder to understand, it also has higher security.<br/></p></div></p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">HTTP/2‚Äôs Advantages</h1><ol type="1" class="numbered-list" start="1"><li><strong>Header Compression (HPACK algorithm)</strong><ul class="bulleted-list"><li style="list-style-type:disc">Previously, we had compression for the <mark class="highlight-red"><strong>body</strong></mark> of requests/responses only using <code>Content-Encoding: gzip</code>. <mark class="highlight-red"><strong>Before HTTP/2, header compression was not possible.</strong></mark></li></ul><ul class="bulleted-list"><li style="list-style-type:disc"><strong>Static Table</strong>: A fixed table that contains common headers and values frequently used in HTTP. Instead of sending the actual header names and values, you can refer to these pre-defined entries.<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Plain Text">Index  Header Name      Header Value
1      :authority
2      :method          GET
3      :method          POST
4      :path            /
5      :path            /index.html
...</code></pre></li></ul><ul class="bulleted-list"><li style="list-style-type:disc"><strong>Dynamic Table</strong>: Stores recently used headers.<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Plain Text">Index  Header Name      Header Value
62     user-agent       Mozilla/5.0 ...
63     cookie           session=abc123
64     custom-header    some-value</code></pre><blockquote class=""><strong>It does not store key-value headers directly</strong>. Instead, it uses a combination of the static and dynamic tables to reduce redundant header data transmission, achieving compression.</blockquote></li></ul></li></ol><ol type="1" class="numbered-list" start="2"><li><strong>Multiplexing (HTTP/2 introduces this concept with just </strong><mark class="highlight-red"><strong>one connection</strong></mark><strong>)</strong><ol type="a" class="numbered-list" start="1"><li>In HTTP/1.0, you must wait for the previous response to complete before sending the next request ‚áí <strong>FIFO (First In First Out)</strong></li></ol><ol type="a" class="numbered-list" start="2"><li><mark class="highlight-red"><strong>HTTP/1.1</strong></mark> allows sending multiple requests without waiting for previous responses, but responses <mark class="highlight-red"><strong>must still come back in order</strong></mark>. If earlier responses are slow, subsequent responses may be delayed, and many HTTP clients do not use this pipelining feature extensively.</li></ol><ol type="a" class="numbered-list" start="3"><li>HTTP/2 allows concurrent responses: It addresses the limitation of response ordering in HTTP/1.1, where responses are not guaranteed to be in sequence.<p class="">A single message (request or response) consists of multiple frames (the smallest unit in HTTP/2) and is transmitted using multiple streams.</p><p class=""><a href="https://stackoverflow.com/questions/34478967/what-is-the-difference-between-http-1-1-pipelining-and-http-2-multiplexing">https://stackoverflow.com/questions/34478967/what-is-the-difference-between-http-1-1-pipelining-and-http-2-multiplexing</a></p><p class="">
</p><p class=""><strong>BUT, it resolves issues at the application layer, </strong><mark class="highlight-red"><strong>but TCP&#x27;s HOLB (Head-of-Line Blocking) remains!</strong></mark></p><p class="">TCP&#x27;s characteristic is that lost packets are retransmitted, and HTTP cannot see TCP operations and must wait. Other unaffected streams continue normally.</p><p class="">
</p></li></ol></li></ol><ol type="1" class="numbered-list" start="3"><li><strong>Server Push</strong>: Checks related resources in the HTML and pushes them along with the main response, similar to link preload.<blockquote class="">In fact, while support for server push as an HTTP protocol feature is new, many Web applications are already using it, just under a different name: <em><mark class="highlight-orange_background">inlining</mark></em>.</blockquote><p class="">However, fundamentally, it&#x27;s different. Given that inlining is already in use, <strong>server push is not as revolutionary</strong>.</p></li></ol><ol type="1" class="numbered-list" start="4"><li><strong>SPDY</strong>: Developed by Google in 2009 as an alternative to HTTP. In 2015, HTTP/2 was standardized based on SPDY by the IETF.<blockquote class="">The spirit of SPDY lives on in HTTP/2. Think of HTTP/2 as the successor to SPDY.</blockquote></li></ol><ol type="1" class="numbered-list" start="5"><li><mark class="highlight-red"><strong>Secure by Default</strong></mark></li></ol><ol type="1" class="numbered-list" start="6"><li><strong>Protocol Negotiation during TLS (NPN/ALPN)</strong>:<p class="">NPN &amp; ALPN are TLS extensions, think of them as <mark class="highlight-red"><strong>TLS add-ons</strong></mark>.</p><ul class="bulleted-list"><li style="list-style-type:disc">NPN (Next Protocol Negotiation) was an extension of SPDY and a precursor to ALPN.<p class=""><mark class="highlight-red"><strong>SPDY leads to HTTP/2, NPN leads to ALPN, which is easier to remember.</strong></mark></p></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">ALPN (Application-Layer Protocol Negotiation) is the extension used by HTTP/2.</li></ul><p class="">Used to decide which application layer protocol to use after establishing the TLS connection, e.g., HTTP 1.0 or HTTP/2.</p></li></ol><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h3 class="">Regardless of Whether the Browser Uses HTTP/1.1 or HTTP/2, Does the Server Respond Based on the Headers?</h3><figure class="image"><a href="https://dl.acm.org/cms/attachment/7bd20d58-b6d3-4cd9-ad73-de7536b30a73/grigorik8.png"><img style="width:528px" src="https://dl.acm.org/cms/attachment/7bd20d58-b6d3-4cd9-ad73-de7536b30a73/grigorik8.png"/></a></figure><ul class="bulleted-list"><li style="list-style-type:disc">GET /news HTTP/1.1</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">GET /news HTTP/2.0</li></ul><p class="">No. The server&#x27;s response is not dependent on the HTTP version in the request <mark class="highlight-red"><strong>but rather on the headers of the request</strong></mark>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre class="code"><code class="language-Plain Text">connection: Upgrade
upgrade: HTTP/2.0</code></pre><p class="">
</p><p class="">
</p><p class="">
</p><h3 class=""><strong>Can HTTP/2.0 Handle Multiple Requests at Once,<br/>and Will the Responses Be Guaranteed in Order?<br/></strong></h3><p class="">In practice, yes, but the mechanism itself does not guarantee it. <mark class="highlight-red"><strong>Stream identifiers</strong></mark> are used to ensure that the <strong>logical</strong> order of requests and responses is maintained.</p><blockquote class="">Overall, HTTP/2&#x27;s multiplexing allows for simultaneous transmission of multiple requests and responses, optimizing performance and resource utilization. While it does not guarantee the order of individual frames, the use of<strong> stream identifiers</strong> and prioritization ensures the integrity and logical order of the requests and responses within the HTTP/2 communication.</blockquote><p class="">
</p><h3 class="">TCP Segments and HTTP/2 Frames: How Do They Relate?</h3><p class=""><strong>Three requests: abc, split into frames: a1, a2, b1, b2, b3, b4, b5, c1. <br/>Can b1-b5 be scattered across different segments?<br/></strong></p><p class=""><mark class="highlight-red"><strong>Yes, this is an efficient way of transmission.</strong></mark></p><figure class="image"><a href="https://dl.acm.org/cms/attachment/7107f5ef-1302-4ec5-9669-d76eef5a91cc/grigorik3.png"><img src="https://dl.acm.org/cms/attachment/7107f5ef-1302-4ec5-9669-d76eef5a91cc/grigorik3.png"/></a></figure><p class="">
</p><p class=""><mark class="highlight-red"><strong>Frames:</strong></mark> In HTTP/2, frames are the <mark class="highlight-red"><strong>smallest unit of data transmission</strong></mark>. Each frame belongs to a specific stream, and a stream corresponds to an individual request.</p><p class=""><strong>Streams are logical divisions, while frames are physical entities transmitted.</strong></p><p class=""><a href="https://stackoverflow.com/questions/39739334/in-http-2-whats-the-relationship-between-req-resp-frame-and-tcp-packet">https://stackoverflow.com/questions/39739334/in-http-2-whats-the-relationship-between-req-resp-frame-and-tcp-packet</a></p><blockquote class="">There is <mark class="highlight-red"><strong>no physical HTTP/2 </strong></mark><em><mark class="highlight-red"><strong>stream</strong></mark></em><mark class="highlight-red"><strong> just like there is no physical TCP stream</strong></mark> - it&#x27;s a higher level concept/abstraction that is handled by the layer in question, which reassembles individual packets or frames into a stream, which makes it infinitely easier to deal with.</blockquote><p class="">During transmission, what actually moves are the frames. The receiving end reassembles the information based on the stream identifiers in each frame. <br/><br/><mark class="highlight-blue"><strong>In simple terms: stream = request, and it includes many frames.</strong></mark></p><p class="">Once at the stream level, streams can be scattered across different TCP segments:</p><ol type="1" class="numbered-list" start="1"><li>HTTP/2&#x27;s multiplexing allows frames from different streams to interleave during transmission.</li></ol><ol type="1" class="numbered-list" start="2"><li>TCP segments are based on packet size and network conditions, not directly related to HTTP/2 frames or streams.</li></ol><p class="">TCP segments can contain many pieces of data. Think of a TCP segment as an outermost package. For efficiency, TCP might combine and split orders (which correspond to different streams).</p><p class=""><strong>So:</strong></p><p class="">A single TCP segment might contain frames a2, b1, c1 (from three different streams).</p><p class="">The next segment might include frames b2 and b3.</p><p class="">A subsequent segment might contain frames a1, b4, b5.</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h3 class=""><strong>If HTTPS is Not Needed and Only HTTP is Required, <br/>Is TLS Negotiation Still Necessary?<br/></strong></h3><p class="">
</p><p class="">When using HTTP (unencrypted), TLS negotiation is not needed. HTTP does not use TLS/SSL encryption, so there is no TLS handshake process in this case.</p><p class="">However, with HTTP/2.0, <mark class="highlight-red"><strong>whether or not to use TLS is not entirely up to you</strong></mark>. Nearly all modern browsers only support <mark class="highlight-red"><strong>HTTP/2 over TLS</strong></mark>. In other words, HTTP/2 will necessarily involve TLS, and you should handle both the TLS handshake and the negotiation for HTTP/2 in one go.</p><blockquote class="">Although the standard itself does not require usage of encryption, <strong>all major client implementations (Firefox, Chrome, Safari, Opera, IE, Edge) have stated that they will only support HTTP/2 over TLS</strong>, which makes encryption de facto mandatory.</blockquote><p class="">
</p><p class="">
</p><p class="">
</p><p class="">
</p><h3 class=""><strong>Does Negotiating HTTP/2 Add an Extra RTT?</strong></h3><p class="">To determine if HTTP/2 is used, there are two methods: <strong>HTTPS negotiation</strong> and the <strong>HTTP Upgrade</strong> header.</p><ol type="1" class="numbered-list" start="1"><li><mark class="highlight-red"><strong>HTTPS negotiation</strong></mark><strong> (aka ALPN, Application-Layer Protocol Negotiation)</strong><ul class="bulleted-list"><li style="list-style-type:disc"><strong>ALPN with TLS 1.3</strong>: Total of 2 RTTs</li></ul><ul class="bulleted-list"><li style="list-style-type:disc"><strong>ALPN with TLS 1.2</strong>: Total of 3 RTTs</li></ul><table class="simple-table"><tbody><tr><td class=""><strong>HTTPS negotiation</strong></td><td class="" style="width:79.99999237060547px">total RTT</td><td class="">TCP</td><td class="">TLS</td></tr><tr><td class=""><strong>ALPN w/ TLS 1.</strong><mark class="highlight-red"><strong>3</strong></mark></td><td class="" style="width:79.99999237060547px">2 RTT =</td><td class="">TCP</td><td class="">1 RTT of TLS 1.3</td></tr><tr><td class=""><strong>ALPN w/ TLS 1.2</strong></td><td class="" style="width:79.99999237060547px">3 RTT =</td><td class="">TCP</td><td class=""><mark class="highlight-red">2</mark> RTT of TLS 1.2</td></tr></tbody></table></li></ol><ol type="1" class="numbered-list" start="2"><li><strong>HTTP Upgrade Header</strong> (only applicable outside of browsers)<ol type="a" class="numbered-list" start="1"><li>In practice, modern browsers support HTTP/2 only over TLS, which means they use the ALPN mechanism during the TLS handshake to agree on the HTTP version.<blockquote class="">Although the standard itself does not require usage of encryption, <strong>all major client implementations (Firefox, Chrome, Safari, Opera, IE, Edge) have stated that they will only support HTTP/2 over TLS</strong>, which makes encryption de facto mandatory.</blockquote></li></ol><ol type="a" class="numbered-list" start="2"><li>Thus, browsers only support <code>h2</code>, not <code>h2c</code>.<p class=""><a href="https://stackoverflow.com/questions/37322430/browser-wont-upgrade-to-h2-http-2-although-upgrade-headers-are-sent">https://stackoverflow.com/questions/37322430/browser-wont-upgrade-to-h2-http-2-although-upgrade-headers-are-sent</a></p></li></ol><ol type="a" class="numbered-list" start="3"><li>If a browser includes <code>Upgrade: h2</code>, it typically shows <mark class="highlight-red"><strong>I can</strong></mark> rather than <mark class="highlight-red"><strong>I want</strong></mark>.</li></ol><p class="">
</p><p class=""><code><strong>Upgrade: h2c</strong></code><strong> can be used in scenarios where encryption is not needed but HTTP/2 upgrade is required.</strong> The client sends an HTTP/1.1 request with the Upgrade header, and regardless of success or failure, it results in 1 RTT.</p><figure class="image"><a href="https://dl.acm.org/cms/attachment/7bd20d58-b6d3-4cd9-ad73-de7536b30a73/grigorik8.png"><img style="width:432px" src="https://dl.acm.org/cms/attachment/7bd20d58-b6d3-4cd9-ad73-de7536b30a73/grigorik8.png"/></a></figure><ul class="bulleted-list"><li style="list-style-type:disc"><strong>Success</strong>: Server responds with <code>101 Switching Protocols</code></li></ul><ul class="bulleted-list"><li style="list-style-type:disc"><strong>Failure</strong>: Server responds with a standard HTTP/1.1 response, indicating the upgrade was not successful.</li></ul><p class="">
</p></li></ol><p class=""><strong>RTT Scenarios for HTTP Upgrade and HTTPS Negotiation</strong></p><p class="">TCP Handshake: Consumes 1 RTT</p><div><table class="simple-table"><tbody><tr><td class="block-color-orange_background"><strong>2.0: HTTP Upgrade Header</strong></td><td class="block-color-orange_background" style="width:79.9928970336914px">total RTT</td><td class="block-color-orange_background" style="width:60.99999237060547px">TCP</td><td class="block-color-orange_background">TLS</td><td class="block-color-orange_background" style="width:162.8536834716797px">Request/Response</td></tr><tr><td class="">‚≠ï¬†<strong>HTTP upgrade + TLS 1.3</strong></td><td class="" style="width:79.9928970336914px">3 RTT =</td><td class="" style="width:60.99999237060547px">TCP</td><td class="">1 RTT of TLS 1.3</td><td class="" style="width:162.8536834716797px">1 RTT of HTTP upgrade</td></tr><tr><td class=""><strong> </strong>‚≠ï¬†<strong>HTTP upgrade w/ TLS 1.2</strong></td><td class="" style="width:79.9928970336914px">4 RTT =</td><td class="" style="width:60.99999237060547px">TCP</td><td class=""><mark class="highlight-red">2</mark> RTT of TLS 1.2</td><td class="" style="width:162.8536834716797px">1</td></tr><tr><td class="">HTTP upgrade failed ‚ùå<br/>(HTTP<br/><mark class="highlight-red">S</mark> 1.1 wth TLS 1.3)</td><td class="" style="width:79.9928970336914px">3 RTT =</td><td class="" style="width:60.99999237060547px">TCP</td><td class="">1 RTT of TLS 1.3</td><td class="" style="width:162.8536834716797px">1 RTT of HTTP req/res</td></tr><tr><td class="">HTTP upgrade failed ‚ùå<br/>(HTTP<br/><mark class="highlight-red">S</mark> 1.1 wth TLS 1.2) </td><td class="" style="width:79.9928970336914px">4 RTT =</td><td class="" style="width:60.99999237060547px">TCP</td><td class=""><mark class="highlight-red">2</mark> RTT of TLS 1.2</td><td class="" style="width:162.8536834716797px">1</td></tr><tr><td class="">HTTP upgrade failed ‚ùå<br/>(HTTP 1.1)<br/></td><td class="" style="width:79.9928970336914px">2 RTT=</td><td class="" style="width:60.99999237060547px">TCP</td><td class="">no TLS</td><td class="" style="width:162.8536834716797px">1</td></tr><tr><td class="block-color-orange_background"><strong>2.0: HTTPS negotiation</strong></td><td class="block-color-orange_background" style="width:79.9928970336914px">total RTT</td><td class="block-color-orange_background" style="width:60.99999237060547px">TCP</td><td class="block-color-orange_background">TLS</td><td class="block-color-orange_background" style="width:162.8536834716797px">Request/Response</td></tr><tr><td class=""><strong>ALPN w/ TLS 1.</strong><mark class="highlight-red"><strong>3 (a)</strong></mark></td><td class="" style="width:79.9928970336914px">3 RTT =</td><td class="" style="width:60.99999237060547px">TCP</td><td class="">1 RTT of TLS 1.3</td><td class="" style="width:162.8536834716797px">1</td></tr><tr><td class=""><strong>ALPN w/ TLS 1.2 (b)</strong></td><td class="" style="width:79.9928970336914px">4RTT =</td><td class="" style="width:60.99999237060547px">TCP</td><td class=""><mark class="highlight-red">2</mark> RTT of TLS 1.2</td><td class="" style="width:162.8536834716797px">1</td></tr><tr><td class=""><strong>ALPN w/ TLS 1.3 (e)</strong></td><td class="" style="width:79.9928970336914px">2RTT =</td><td class="" style="width:60.99999237060547px">TCP</td><td class="">0: Session Resumption</td><td class="" style="width:162.8536834716797px">1</td></tr><tr><td class="block-color-orange_background">HTTP 3.0</td><td class="block-color-orange_background" style="width:79.9928970336914px"></td><td class="block-color-orange_background" style="width:60.99999237060547px"></td><td class="block-color-orange_background">QUIC including TCP</td><td class="block-color-orange_background" style="width:162.8536834716797px">Request/Response</td></tr><tr><td class="">HTTP 3.0 QUIC (c)</td><td class="" style="width:79.9928970336914px">2</td><td class="" style="width:60.99999237060547px">x</td><td class="">1</td><td class="" style="width:162.8536834716797px">1</td></tr><tr><td class="">HTTP 3.0 QUIC (f)</td><td class="" style="width:79.9928970336914px">1</td><td class="" style="width:60.99999237060547px">x</td><td class="">0: Session Resumption</td><td class="" style="width:162.8536834716797px">1</td></tr></tbody></table></div><p class="">To answer the original question: <mark class="highlight-red"><strong>negotiating HTTP/2 does not add an extra RTT</strong></mark>. </p><ol type="1" class="numbered-list" start="1"><li>The <strong>HTTP</strong> <strong>negotiation</strong> is part of the TLS handshake process.</li></ol><ol type="1" class="numbered-list" start="2"><li>Even if using the HTTP Upgrade header, regardless of success or failure, it results in only 1 RTT.There is no additional RTT for failure scenarios where the client needs to resend the request.</li></ol><p class="">
</p><p class="">
</p><p class="">
</p><h1 class="">HTTP 3.0 </h1><p class=""><mark class="highlight-red"><strong>aka HTTP QUIC</strong></mark></p><p class=""><strong>Based on UDP</strong>, and it addresses the shortcomings of UDP, such as:</p><ul class="bulleted-list"><li style="list-style-type:disc">TCP-like congestion control</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">loss recovery</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Uses TLS 1.3</li></ul><p class=""><strong>Advantages over HTTP/2.0:</strong></p><p class=""><strong>HTTP/3 is almost identical to HTTP/2, except that HTTP/3 integrates TLS within QUIC</strong></p><ul class="bulleted-list"><li style="list-style-type:disc">Reduce connection establishment latency<ul class="bulleted-list"><li style="list-style-type:circle">Improved congestion control</li></ul></li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Multiplexing without head-of-line blocking</li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Forward error correction </li></ul><ul class="bulleted-list"><li style="list-style-type:disc">Connection migration (e.g., during Wi-Fi or 4G switching, no need to reconnect)</li></ul><p class="">
</p><p class="">
</p><p class="">
</p><h3 class=""><strong>HTTP/3.0 is by default encrypted with TLS. How it achieve 0-RTT?</strong></h3><p class="">0-RTT Definition: During the encryption process, <mark class="highlight-red">requests are sent simultaneously</mark>, which means that <mark class="highlight-red">during the TLS handshake</mark>, requests can be sent together.</p><p class=""><strong>Additionally, TLS handshake is incorporated within QUIC, eliminating an extra step.</strong></p><p class=""><a href="https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/">https://www.smashingmagazine.com/2021/08/http3-performance-improvements-part2/</a></p><div class="column-list"><div style="width:50%" class="column"><figure class="image"><a href="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9f4c69d1-5ab6-4ca2-ad1e-ec68d99dc9ab/connection-setup-1.png"><img style="width:432px" src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9f4c69d1-5ab6-4ca2-ad1e-ec68d99dc9ab/connection-setup-1.png"/></a></figure></div><div style="width:50%" class="column"><figure class="image"><a href="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ddbd604f-cec4-4e61-9172-707eda88bc99/connection-setup-2.png"><img style="width:432px" src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/ddbd604f-cec4-4e61-9172-707eda88bc99/connection-setup-2.png"/></a></figure></div></div><div></div><p class="">Note: 0-RTT does not mean completely eliminating RTT; it refers to the feature of <strong>Session Resumption</strong> in TLS that saves steps. So, in HTTP/2, session resumption still requires a separate TCP handshake.</p><p class="">For HTTP/3, since QUIC incorporates TCP, the remaining 2 steps are directly reduced to one step.</p><p class=""><strong>Session resumption enables reducing it to one RTT directly.</strong></p><p class="">
</p><h1 class="">Resources</h1><p class=""><a href="https://blog.apnic.net/2023/09/25/why-http-3-is-eating-the-world/">https://blog.apnic.net/2023/09/25/why-http-3-is-eating-the-world/</a></p><p class=""><a href="https://medium.com/@chester.yw.chu/http-3-ÂÇ≥Ëº∏ÂçîË≠∞-quic-Á∞°‰ªã-5f8806d6c8cd">https://medium.com/@chester.yw.chu/http-3-ÂÇ≥Ëº∏ÂçîË≠∞-quic-Á∞°‰ªã-5f8806d6c8cd</a></p><p class=""><a href="https://engineering.cred.club/head-of-line-hol-blocking-in-http-1-and-http-2-50b24e9e3372">https://engineering.cred.club/head-of-line-hol-blocking-in-http-1-and-http-2-50b24e9e3372</a></p><p class=""><a href="https://blog.csdn.net/m0_49147102/article/details/134480975">https://blog.csdn.net/m0_49147102/article/details/134480975</a></p><p class=""><a href="https://dl.acm.org/doi/pdf/10.1145/2542661">https://dl.acm.org/doi/pdf/10.1145/2542661</a></p><p class=""><a href="https://www.cnblogs.com/flydean/p/15419443.html">https://www.cnblogs.com/flydean/p/15419443.html</a></p><p class="">
</p><p class="">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body>